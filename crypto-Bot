#!/usr/bin/env python3
# coding: utf-8
"""
Trader bot main script
- Ø§Ø¬Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø³Ø±ÙˆÛŒØ³: Ø®ÙˆØ§Ù†Ø¯Ù† ØªÙˆÚ©Ù† Ø§Ø² env, Ø­Ù„Ù‚Ù‡ ØªÚ©Ø±Ø§Ø± Ù‡Ø± N Ø«Ø§Ù†ÛŒÙ‡
- Ù„Ø§Ú¯ Ø¯Ø± ÙØ§ÛŒÙ„ Ùˆ Ú†Ø§Ù¾ Ø¯Ø± Ú©Ù†Ø³ÙˆÙ„
- Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ccxt Ø¨Ø±Ø§ÛŒ fetch ticker/ohlcv Ùˆ pandas/pandas_ta Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
"""

import os
import sys
import time
import signal
import traceback
from datetime import datetime
import requests
import ccxt
import pandas as pd
import pandas_ta as ta

# ---------------------------
# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø§ÛŒÙ‡ (Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ± Ø§Ø² env)
# ---------------------------
BOT_TOKEN = os.getenv("BOT_TOKEN")               # ØªÙˆÚ©Ù† Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù…
CHAT_ID = os.getenv("CHAT_ID")                   # chat id ÛŒØ§ Ú©Ø§Ù†Ø§Ù„
SLEEP_INTERVAL = int(os.getenv("SLEEP_INTERVAL", "900"))  # Ø«Ø§Ù†ÛŒÙ‡ Ø¨ÛŒÙ† Ù‡Ø± Ø³ÛŒÚ©Ù„ (Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 15 Ø¯Ù‚ÛŒÙ‚Ù‡)
LOG_FILE = os.getenv("LOG_FILE", "trader_bot_log.txt")
TIMEFRAMES = os.getenv("TIMEFRAMES", "45m,4h").split(",")
RISK_REWARD = float(os.getenv("RISK_REWARD", "2"))
FIBO_LOOKBACK = int(os.getenv("FIBO_LOOKBACK", "50"))
VOLUME_LOOKBACK = int(os.getenv("VOLUME_LOOKBACK", "20"))
MIN_24H_VOLUME_USDT = float(os.getenv("MIN_24H_VOLUME_USDT", "5000000"))
MIN_24H_GROWTH_PERCENT = float(os.getenv("MIN_24H_GROWTH_PERCENT", "10"))
MAX_SYMBOLS_TO_PROCESS = int(os.getenv("MAX_SYMBOLS_TO_PROCESS", "100"))
EXCHANGE_ID = os.getenv("EXCHANGE_ID", "kucoin").lower()  # default kucoin
FETCH_TICKERS_RETRIES = int(os.getenv("FETCH_TICKERS_RETRIES", "3"))

# ---------------------------
# Ø§Ù…Ù† Ø®Ø±ÙˆØ¬ Ø¨Ø§ Ø³ÛŒÚ¯Ù†Ø§Ù„
# ---------------------------
SHUTDOWN = False


def _signal_handler(sig, frame):
    global SHUTDOWN
    log_message(f"Received signal {sig}. Preparing to shutdown gracefully...", "INFO")
    SHUTDOWN = True


for s in (signal.SIGINT, signal.SIGTERM):
    try:
        signal.signal(s, _signal_handler)
    except Exception:
        pass

# ---------------------------
# Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§Ú©Ø³Ú†Ù†Ø¬ ccxt
# ---------------------------
def make_exchange():
    """Ø§ÛŒÙ†Ø¬Ø§ Ø§Ú¯Ø± Ù†ÛŒØ§Ø² Ø¨Ù‡ API KEY/SECRET Ø¯Ø§Ø±ÛŒØŒ Ø§Ø² env Ø¨Ø®ÙˆÙ†"""
    api_key = os.getenv("EXCHANGE_API_KEY")
    api_secret = os.getenv("EXCHANGE_API_SECRET")
    opts = {"enableRateLimit": True}
    try:
        if EXCHANGE_ID == "kucoin":
            ex = ccxt.kucoin(opts)
        elif EXCHANGE_ID == "binance":
            ex = ccxt.binance(opts)
        elif EXCHANGE_ID == "gate":
            ex = ccxt.gate(opts)
        else:
            # fallback Ø¨Ù‡ kucoin
            ex = ccxt.kucoin(opts)
    except Exception as e:
        # fallback safe
        ex = ccxt.kucoin(opts)
    if api_key and api_secret:
        try:
            ex.apiKey = api_key
            ex.secret = api_secret
        except Exception:
            pass
    return ex


exchange = make_exchange()

# ---------------------------
# Utility: logging + telegram
# ---------------------------
def log_message(message, level="INFO"):
    """Ø«Ø¨Øª Ù¾ÛŒØ§Ù… Ø¯Ø± ÙØ§ÛŒÙ„ Ù„Ø§Ú¯ Ùˆ Ú†Ø§Ù¾ Ø¯Ø± Ú©Ù†Ø³ÙˆÙ„"""
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    entry = f"[{timestamp}] [{level}] {message}"
    print(entry, flush=True)
    try:
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(entry + "\n")
    except Exception as e:
        # Ø§Ú¯Ø± Ù„Ø§Ú¯ ÙØ§ÛŒÙ„ Ù‡Ù… Ø§ÛŒØ±Ø§Ø¯ Ø¯Ø§Ø´ØªØŒ Ø­Ø¯Ø§Ù‚Ù„ Ø¯Ø± Ú©Ù†Ø³ÙˆÙ„ Ú†Ø§Ù¾ Ø´Ø¯Ù‡
        print(f"[{timestamp}] [ERROR] Cannot write log file: {e}", flush=True)


def send_telegram_message(text):
    """Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… â€” Ø§Ú¯Ø± ØªÙˆÚ©Ù† ÛŒØ§ Ú†Øª Ø¢ÛŒØ¯ÛŒ Ù†Ø¨Ø§Ø´Ø¯ØŒ Ø«Ø¨Øª Ø§Ø±ÙˆØ± Ø¯Ø± Ù„Ø§Ú¯"""
    if not BOT_TOKEN or not CHAT_ID:
        log_message("BOT_TOKEN or CHAT_ID not provided. Skipping Telegram send.", "WARNING")
        return False
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        payload = {"chat_id": CHAT_ID, "text": text, "parse_mode": "Markdown"}
        resp = requests.post(url, json=payload, timeout=20)
        if resp.status_code != 200:
            log_message(f"Telegram API returned {resp.status_code}: {resp.text}", "ERROR")
            return False
        return True
    except Exception as e:
        log_message(f"Exception sending telegram message: {e}", "ERROR")
        return False

# ---------------------------
# Market scan: hot symbols
# ---------------------------
def get_hot_symbols():
    """Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ Ø­Ø¬Ù… Ùˆ Ø±Ø´Ø¯ Û²Û´ Ø³Ø§Ø¹ØªÙ‡"""
    log_message("Starting market scan for hot assets...")
    for attempt in range(FETCH_TICKERS_RETRIES):
        try:
            tickers = exchange.fetch_tickers()
            hot_symbols = []
            for symbol, ticker in tickers.items():
                try:
                    # ÙÛŒÙ„ØªØ± USDT
                    if not symbol.endswith("/USDT"):
                        continue
                    # skip swap labels if present
                    if "swap" in symbol.lower():
                        continue

                    volume_usdt = ticker.get("quoteVolume") or ticker.get("baseVolume") or ticker.get("quoteVolume")
                    # Ø¨Ø¹Ø¶ÛŒ Ø§Ú©Ø³Ú†Ù†Ø¬â€ŒÙ‡Ø§ Ø³Ø§Ø®ØªØ§Ø± Ù…ØªÙØ§ÙˆØª Ø¯Ø§Ø±Ù†Ø¯Ø› Ø§Ù…Ù†â€ŒØ³Ø§Ø²ÛŒ:
                    try:
                        volume_usdt = float(volume_usdt) if volume_usdt is not None else 0.0
                    except Exception:
                        volume_usdt = 0.0

                    percentage_change = ticker.get("percentage") or ticker.get("percentageChange") or ticker.get("change")
                    try:
                        percentage_change = float(percentage_change) if percentage_change is not None else 0.0
                    except Exception:
                        percentage_change = 0.0

                    if volume_usdt and volume_usdt >= MIN_24H_VOLUME_USDT:
                        if abs(percentage_change) >= MIN_24H_GROWTH_PERCENT:
                            hot_symbols.append(symbol)
                        elif volume_usdt >= MIN_24H_VOLUME_USDT * 5:
                            hot_symbols.append(symbol)
                except Exception:
                    # Ù…Ø­Ø§ÙØ¸Øª Ø¯Ø± Ø¨Ø±Ø§Ø¨Ø± ticker ØºÛŒØ±Ù…Ø¹Ù…ÙˆÙ„
                    continue

            hot_symbols = list(dict.fromkeys(hot_symbols))  # remove duplicates, keep order
            if len(hot_symbols) > MAX_SYMBOLS_TO_PROCESS:
                hot_symbols = hot_symbols[:MAX_SYMBOLS_TO_PROCESS]

            log_message(f"Found {len(hot_symbols)} hot symbols to analyze.")
            return hot_symbols
        except Exception as e:
            log_message(f"Error fetching tickers (Attempt {attempt + 1}): {e}. Retrying...", "WARNING")
            time.sleep(5)
    log_message("Failed to fetch tickers after retries.", "ERROR")
    return []

# ---------------------------
# Data fetching + indicators
# ---------------------------
def fetch_and_calculate_data(symbol, timeframe):
    """Ø¯Ø±ÛŒØ§ÙØª OHLCV Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA200, RSI, ATR Ùˆ Ø­Ø¬Ù… Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†"""
    try:
        # limit Ø­Ø¯ÙˆØ¯ 300 Ú©Ù†Ø¯Ù„ØŒ Ú©Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ ÙÛŒØ¨Ùˆ Ùˆ EMA200
        bars = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=300)
        if not bars:
            return None
        df = pd.DataFrame(bars, columns=["time", "open", "high", "low", "close", "volume"])
        df["time"] = pd.to_datetime(df["time"], unit="ms")
        # Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
        # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² pandas_ta. Ø¯Ø± Ø¨Ø¹Ø¶ÛŒ ÙˆØ±Ú˜Ù†â€ŒÙ‡Ø§ ØªØ§Ø¨Ø¹ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒ Ø¯ÛŒØªØ§ÙØ±ÛŒÙ…/Ø³Ø±ÛŒØ² Ù…ØªÙØ§ÙˆØª Ø§Ø³ØªØ› Ø§Ù…Ù† Ø¨Ù†ÙˆÛŒØ³ÛŒÙ…:
        try:
            ema200 = ta.ema(df["close"], length=200)
            if isinstance(ema200, pd.Series):
                df["ema200"] = ema200
            else:
                df["ema200"] = ema200.iloc[:, 0] if hasattr(ema200, "iloc") else ema200
        except Exception:
            # fallback Ø³Ø§Ø¯Ù‡â€ŒØªØ±
            df["ema200"] = df["close"].ewm(span=200, adjust=False).mean()

        try:
            df["rsi"] = ta.rsi(df["close"], length=14)
        except Exception:
            df["rsi"] = df["close"].diff().apply(lambda x: 0)  # placeholder if ta fails

        try:
            df["atr"] = ta.atr(df["high"], df["low"], df["close"], length=14)
        except Exception:
            df["atr"] = (df["high"] - df["low"]).rolling(14).mean()

        df["avg_vol"] = df["volume"].rolling(window=VOLUME_LOOKBACK, min_periods=1).mean()
        return df
    except Exception as e:
        log_message(f"fetch_and_calculate_data error for {symbol} {timeframe}: {e}", "ERROR")
        return None

# ---------------------------
# Fibonacci confluence check
# ---------------------------
def check_fibo_confluence(df, is_long):
    """Ú†Ú© Ú©Ø±Ø¯Ù† Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ù‚ÛŒÙ…Øª Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ 50% - 61.8% ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ"""
    if df is None or len(df) < FIBO_LOOKBACK + 1:
        return False
    recent = df.iloc[-FIBO_LOOKBACK - 1:-1]  # exclude current candle for swing calc
    swing_high = recent["high"].max()
    swing_low = recent["low"].min()
    if pd.isna(swing_high) or pd.isna(swing_low) or swing_high == swing_low:
        return False
    current_price = df.iloc[-1]["close"]
    price_range = swing_high - swing_low
    fibo_50 = swing_high - (price_range * 0.50)
    fibo_618 = swing_high - (price_range * 0.618)
    if is_long:
        return fibo_618 < current_price < fibo_50
    else:
        fibo_50_short = swing_low + (price_range * 0.50)
        fibo_618_short = swing_low + (price_range * 0.618)
        return fibo_50_short < current_price < fibo_618_short

# ---------------------------
# Strategy logic
# ---------------------------
def strategy_logic(df, symbol, timeframe):
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù„Ø§Ù†Ú¯/Ø´ÙˆØ±Øª Ùˆ Ù¾ÛŒØ§Ù… Ø®Ø±ÙˆØ¬ÛŒ"""
    try:
        if df is None or len(df) < 200 or pd.isna(df["ema200"].iloc[-1]):
            return None
        last = df.iloc[-1]
        current_price = float(last["close"])
        ema_200 = float(last["ema200"])
        rsi = float(last["rsi"]) if not pd.isna(last["rsi"]) else 50.0
        atr = float(last["atr"]) if not pd.isna(last["atr"]) else 0.0
        current_volume = float(last["volume"])
        avg_volume = float(last["avg_vol"]) if not pd.isna(last["avg_vol"]) else 0.0

        # LONG condition
        trend_is_bullish = current_price > ema_200
        is_long_pullback = rsi < 40

        if trend_is_bullish and is_long_pullback:
            star_count = 1
            if check_fibo_confluence(df, is_long=True):
                star_count += 1
            if current_volume > avg_volume:
                star_count += 1
            stop_loss = current_price - (atr * 1.5) if atr > 0 else current_price * 0.99
            risk = current_price - stop_loss
            take_profit = current_price + (risk * RISK_REWARD)
            stars = "â­ï¸" * star_count
            msg = (
                f"âœ… *LONG BUY SIGNAL* {stars}\n"
                f"-------------------------------\n"
                f"ğŸ“ˆ *Confidence:* {star_count} Stars\n"
                f"ğŸ’ *Coin:* {symbol} (TF: {timeframe})\n"
                f"ğŸ’° *ENTRY:* {current_price:.8f}\n"
                f"ğŸ¯ *TP:* {take_profit:.8f}\n"
                f"ğŸ›‘ *SL:* {stop_loss:.8f}\n"
                f"âš–ï¸ *R/R Ratio:* 1:{RISK_REWARD}"
            )
            return msg

        # SHORT condition
        trend_is_bearish = current_price < ema_200
        is_short_pullback = rsi > 60

        if trend_is_bearish and is_short_pullback:
            star_count = 1
            if check_fibo_confluence(df, is_long=False):
                star_count += 1
            if current_volume > avg_volume:
                star_count += 1
            stop_loss = current_price + (atr * 1.5) if atr > 0 else current_price * 1.01
            risk = stop_loss - current_price
            take_profit = current_price - (risk * RISK_REWARD)
            stars = "â­ï¸" * star_count
            msg = (
                f"ğŸ”´ *SHORT SELL SIGNAL* {stars}\n"
                f"-------------------------------\n"
                f"ğŸ“‰ *Confidence:* {star_count} Stars\n"
                f"ğŸ’ *Coin:* {symbol} (TF: {timeframe})\n"
                f"ğŸ’° *ENTRY:* {current_price:.8f}\n"
                f"ğŸ¯ *TP:* {take_profit:.8f}\n"
                f"ğŸ›‘ *SL:* {stop_loss:.8f}\n"
                f"âš–ï¸ *R/R Ratio:* 1:{RISK_REWARD}"
            )
            return msg

        return None
    except Exception as e:
        log_message(f"strategy_logic error for {symbol} {timeframe}: {e}", "ERROR")
        return None

# ---------------------------
# Run one full cycle
# ---------------------------
def run_trading_bot_cycle():
    """Ø§Ø¬Ø±Ø§ÛŒ ÛŒÚ© Ø³ÛŒÚ©Ù„ Ú©Ø§Ù…Ù„: Ø§Ø³Ú©Ù†ØŒ ØªØ­Ù„ÛŒÙ„ Ùˆ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…"""
    log_message("Trader Bot Cycle Initiated.", "INFO")
    if not BOT_TOKEN or not CHAT_ID:
        log_message("BOT_TOKEN or CHAT_ID not set. Skipping cycle.", "CRITICAL")
        return

    # Ø§Ø¹Ù„Ø§Ù† Ø´Ø±ÙˆØ¹ Ú†Ø±Ø®Ù‡
    try:
        send_telegram_message(f"âœ… *Ø±Ø¨Ø§Øª ØªØ±ÛŒØ¯Ø± ÙØ¹Ø§Ù„ Ø´Ø¯!* \nğŸ•°ï¸ Ø²Ù…Ø§Ù† Ø§Ø¬Ø±Ø§: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} (UTC)\n_Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø± Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù… Ø§Ø³Øª..._")
    except Exception:
        pass

    symbols = get_hot_symbols()
    if not symbols:
        log_message("No symbols to process this cycle.", "INFO")
        return

    for timeframe in TIMEFRAMES:
        log_message(f"Starting analysis for timeframe: {timeframe}", "INFO")
        for symbol in symbols:
            if SHUTDOWN:
                log_message("Shutdown requested. Breaking symbol loop.", "INFO")
                return
            try:
                df = fetch_and_calculate_data(symbol, timeframe)
                if df is None:
                    log_message(f"Could not fetch data for {symbol} on {timeframe}.", "WARNING")
                    continue
                signal = strategy_logic(df, symbol, timeframe)
                if signal:
                    ok = send_telegram_message(signal)
                    log_message(f"SIGNAL FOUND: {symbol} on {timeframe}. Sent to Telegram: {ok}", "SUCCESS")
                    # Ú©ÙˆØªØ§Ù‡ÛŒ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø±ÛŒØª Ù„ÛŒÙ…ÛŒØª ØªÙ„Ú¯Ø±Ø§Ù… / Ø§Ú©Ø³Ú†Ù†Ø¬
                    time.sleep(2)
            except Exception as e:
                log_message(f"Unexpected error for {symbol} {timeframe}: {e}", "ERROR")
                log_message(traceback.format_exc(), "DEBUG")
                time.sleep(1)

    log_message("Scan cycle complete.", "INFO")

# ---------------------------
# Main loop
# ---------------------------
def main_loop():
    log_message("Trader bot service starting...", "INFO")
    # ÛŒÚ© Ù¾ÛŒØ§Ù… Ø§ÙˆÙ„ÛŒÙ‡ Ø¯Ø± Ù„Ø§Ú¯ Ø¨ÙØ±Ø³Øª
    log_message(f"Configuration: TIMEFRAMES={TIMEFRAMES}, SLEEP_INTERVAL={SLEEP_INTERVAL}s, EXCHANGE={EXCHANGE_ID}", "INFO")

    # Ø­Ù„Ù‚Ù‡ ØªØ§ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø´Ø§Øªâ€ŒØ¯Ø§ÙˆÙ† Ù†ÛŒÙˆÙ…Ø¯Ù‡
    while not SHUTDOWN:
        try:
            run_trading_bot_cycle()
        except Exception as e:
            log_message(f"run_trading_bot_cycle crashed: {e}", "ERROR")
            log_message(traceback.format_exc(), "DEBUG")
        # Ù‚Ø¨Ù„ Ø§Ø² Ø®ÙˆØ§Ø¨ØŒ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ú©Ù‡ Ø¢ÛŒØ§ shutdown Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ø¯Ù‡ ÛŒØ§ Ù†Ù‡
        for i in range(0, SLEEP_INTERVAL, 5):
            if SHUTDOWN:
                break
            time.sleep(5)
    log_message("Service stopped gracefully.", "INFO")


if __name__ == "__main__":
    try:
        main_loop()
    except Exception as e:
        log_message(f"Fatal error in main: {e}", "CRITICAL")
        log_message(traceback.format_exc(), "DEBUG")
        sys.exit(1)
